/* Generated by itemis CREATE code generator. */

#ifndef STATECHART_H_
#define STATECHART_H_

/*!
Forward declaration for the Statechart state machine.
*/
class Statechart;


#include "../src/sc_types.h"
#include "../src/sc_statemachine.h"
#include "../src/sc_cyclebased.h"
#include "../src/sc_timer.h"
#include <string.h>

/*! \file
Header of the state machine 'Statechart'.
*/


class Statechart : public sc::timer::TimedInterface, public sc::CycleBasedInterface
{
	public:
		Statechart() noexcept;
		
		virtual ~Statechart();
		
		
		
		/*! Enumeration of all states. */
		enum class State
		{
			NO_STATE,
			main_region_StateA,
			main_region_StateB,
			main_region_StateC,
			main_region_UART_config
		};
		
		/*! The number of states. */
		static constexpr const sc::integer numStates {4};
		static constexpr const sc::integer scvi_main_region_StateA {0};
		static constexpr const sc::integer scvi_main_region_StateB {0};
		static constexpr const sc::integer scvi_main_region_StateC {0};
		static constexpr const sc::integer scvi_main_region_UART_config {0};
		/*! Raises the in event 'myEvent' of default interface scope. */
		void raiseMyEvent() noexcept;
		
		
		//! Inner class for default interface scope operation callbacks.
		class OperationCallback
		{
			public:
				virtual ~OperationCallback() = 0;
				
				virtual void configUart() = 0;
				
				virtual void configGPIO() = 0;
				
				virtual void writeUart(std::string message) = 0;
				
				virtual void writeLed(sc::integer value) = 0;
				
				
		};
		
		/*! Set the working instance of the operation callback interface 'OperationCallback'. */
		void setOperationCallback(OperationCallback* operationCallback) noexcept;
		
		
		/*
		 * Functions inherited from StatemachineInterface
		 */
		 void enter() override;
		
		 void exit() override;
		
		void runCycle() override;
		
		/*!
		 * Checks if the state machine is active (until 2.4.1 this method was used for states).
		 * A state machine is active if it has been entered. It is inactive if it has not been entered at all or if it has been exited.
		 */
		 bool isActive() const noexcept override;
		
		
		/*!
		* Checks if all active states are final. 
		* If there are no active states then the state machine is considered being inactive. In this case this method returns false.
		*/
		 bool isFinal() const noexcept override;
		
		/*! 
		 * Checks if member of the state machine must be set. For example an operation callback.
		 */
		bool check() const noexcept;
		
		/*
		 * Functions inherited from TimedStatemachineInterface
		 */
		void setTimerService(sc::timer::TimerServiceInterface* timerService_) noexcept override;
		
		sc::timer::TimerServiceInterface* getTimerService() noexcept override;
		
		void raiseTimeEvent(sc::eventid event) noexcept override;
		
		sc::integer getNumberOfParallelTimeEvents() noexcept override;
		
		
		
		/*! Checks if the specified state is active (until 2.4.1 the used method for states was calles isActive()). */
		bool isStateActive(State state) const noexcept;
		
		//! number of time events used by the state machine.
		static const sc::integer timeEventsCount {2};
		
		//! number of time events that can be active at once.
		static const sc::integer parallelTimeEventsCount {1};
		
		
	protected:
		
		
		
		
	private:
		Statechart(const Statechart &rhs);
		Statechart& operator=(const Statechart&);
		
		
		
		
		//! the maximum number of orthogonal states defines the dimension of the state configuration vector.
		static const sc::ushort maxOrthogonalStates {1};
		
		sc::timer::TimerServiceInterface* timerService;
		bool timeEvents[timeEventsCount];
		
		
		State stateConfVector[maxOrthogonalStates];
		
		
		
		OperationCallback* ifaceOperationCallback;
		
		typedef struct {
			bool myEvent_raised;
		}StatechartIfaceEvBuf;
		typedef struct {
			bool Statechart_main_region_StateA_time_event_0_raised;
			bool Statechart_main_region_StateC_time_event_0_raised;
		}StatechartTimeEventsEvBuf;
		typedef struct {
			StatechartIfaceEvBuf iface;
			StatechartTimeEventsEvBuf timeEvents;
		}StatechartEvBuf;
		bool completed {false};
		bool doCompletion {false};
		StatechartEvBuf current {};
		bool isExecuting {false};
		
		
		
		// prototypes of all internal functions
		
		void enact_main_region_StateA();
		void enact_main_region_StateB();
		void enact_main_region_StateC();
		void enact_main_region_UART_config();
		void exact_main_region_StateA();
		void exact_main_region_StateC();
		void enseq_main_region_StateA_default();
		void enseq_main_region_StateB_default();
		void enseq_main_region_UART_config_default();
		void enseq_main_region_default();
		void exseq_main_region_StateA();
		void exseq_main_region_StateB();
		void exseq_main_region_StateC();
		void exseq_main_region_UART_config();
		void exseq_main_region();
		void react_main_region__entry_Default();
		sc::integer main_region_StateA_react(const sc::integer transitioned_before);
		sc::integer main_region_StateB_react(const sc::integer transitioned_before);
		sc::integer main_region_StateC_react(const sc::integer transitioned_before);
		sc::integer main_region_UART_config_react(const sc::integer transitioned_before);
		void swapInEvents() noexcept;
		void clearCurrentEvents();
		void clearInEvents() noexcept;
		void microStep();
		
		
		
		/*! Indicates event 'myEvent' of default interface scope is active. */
		bool myEvent_raised {false};
		
		
		
};


inline Statechart::OperationCallback::~OperationCallback() {}


#endif /* STATECHART_H_ */
