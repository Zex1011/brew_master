/** Generated by itemis CREATE code generator. */

#include "Statechart.h"

/*! \file
Implementation of the state machine 'Statechart'
*/




Statechart::Statechart() noexcept
{
	for (sc::ushort state_vec_pos = 0; state_vec_pos < maxOrthogonalStates; ++state_vec_pos)
		stateConfVector[state_vec_pos] = Statechart::State::NO_STATE;
	
	clearInEvents();
	swapInEvents();
}

Statechart::~Statechart()
{
}



void Statechart::raiseMyEvent() noexcept {
	myEvent_raised = true;
}



bool Statechart::isActive() const noexcept
{
	return stateConfVector[0] != Statechart::State::NO_STATE;
}

/* 
 * Always returns 'false' since this state machine can never become final.
 */
bool Statechart::isFinal() const noexcept
{
	   return false;
}

bool Statechart::check() const noexcept{
	if(timerService == nullptr) {
		return false;
	}
	if (this->ifaceOperationCallback == nullptr) {
		return false;
	}
	return true;
}


void Statechart::setTimerService(sc::timer::TimerServiceInterface* timerService_) noexcept
{
	this->timerService = timerService_;
}

sc::timer::TimerServiceInterface* Statechart::getTimerService() noexcept
{
	return timerService;
}

sc::integer Statechart::getNumberOfParallelTimeEvents() noexcept {
	return parallelTimeEventsCount;
}

void Statechart::raiseTimeEvent(sc::eventid evid) noexcept
{
	if (evid < timeEventsCount)
	{
		timeEvents[evid] = true;
	}
}


bool Statechart::isStateActive(State state) const noexcept
{
	switch (state)
	{
		case Statechart::State::main_region_StateA :
		{
			return  (stateConfVector[scvi_main_region_StateA] == Statechart::State::main_region_StateA);
			break;
		}
		case Statechart::State::main_region_StateB :
		{
			return  (stateConfVector[scvi_main_region_StateB] == Statechart::State::main_region_StateB);
			break;
		}
		case Statechart::State::main_region_StateC :
		{
			return  (stateConfVector[scvi_main_region_StateC] == Statechart::State::main_region_StateC);
			break;
		}
		case Statechart::State::main_region_UART_config :
		{
			return  (stateConfVector[scvi_main_region_UART_config] == Statechart::State::main_region_UART_config);
			break;
		}
		default:
		{
			/* State is not active*/
			return false;
			break;
		}
	}
}

void Statechart::setOperationCallback(OperationCallback* operationCallback) noexcept
{
	ifaceOperationCallback = operationCallback;
}

// implementations of all internal functions
/* Entry action for state 'StateA'. */
void Statechart::enact_main_region_StateA()
{
	/* Entry action for state 'StateA'. */
	timerService->setTimer(this, 0, (2 * 1000), false);
	ifaceOperationCallback->writeUart("state_a");
	ifaceOperationCallback->writeLed(1);
}

void Statechart::enact_main_region_StateB()
{
	/* Entry action for state 'StateB'. */
	ifaceOperationCallback->writeUart("state_b");
	ifaceOperationCallback->writeLed(0);
	completed = true;
}

/* Entry action for state 'StateC'. */
void Statechart::enact_main_region_StateC()
{
	/* Entry action for state 'StateC'. */
	timerService->setTimer(this, 1, (2 * 1000), false);
	ifaceOperationCallback->writeUart("state_c");
}

void Statechart::enact_main_region_UART_config()
{
	/* Entry action for state 'UART_config'. */
	ifaceOperationCallback->configUart();
	ifaceOperationCallback->configGPIO();
	completed = true;
}

/* Exit action for state 'StateA'. */
void Statechart::exact_main_region_StateA()
{
	/* Exit action for state 'StateA'. */
	timerService->unsetTimer(this, 0);
}

/* Exit action for state 'StateC'. */
void Statechart::exact_main_region_StateC()
{
	/* Exit action for state 'StateC'. */
	timerService->unsetTimer(this, 1);
}

/* 'default' enter sequence for state StateA */
void Statechart::enseq_main_region_StateA_default()
{
	/* 'default' enter sequence for state StateA */
	enact_main_region_StateA();
	stateConfVector[0] = Statechart::State::main_region_StateA;
}

/* 'default' enter sequence for state StateB */
void Statechart::enseq_main_region_StateB_default()
{
	/* 'default' enter sequence for state StateB */
	enact_main_region_StateB();
	stateConfVector[0] = Statechart::State::main_region_StateB;
}

/* 'default' enter sequence for state UART_config */
void Statechart::enseq_main_region_UART_config_default()
{
	/* 'default' enter sequence for state UART_config */
	enact_main_region_UART_config();
	stateConfVector[0] = Statechart::State::main_region_UART_config;
}

/* 'default' enter sequence for region main region */
void Statechart::enseq_main_region_default()
{
	/* 'default' enter sequence for region main region */
	react_main_region__entry_Default();
}

/* Default exit sequence for state StateA */
void Statechart::exseq_main_region_StateA()
{
	/* Default exit sequence for state StateA */
	stateConfVector[0] = Statechart::State::NO_STATE;
	exact_main_region_StateA();
}

/* Default exit sequence for state StateB */
void Statechart::exseq_main_region_StateB()
{
	/* Default exit sequence for state StateB */
	stateConfVector[0] = Statechart::State::NO_STATE;
}

/* Default exit sequence for state StateC */
void Statechart::exseq_main_region_StateC()
{
	/* Default exit sequence for state StateC */
	stateConfVector[0] = Statechart::State::NO_STATE;
	exact_main_region_StateC();
}

/* Default exit sequence for state UART_config */
void Statechart::exseq_main_region_UART_config()
{
	/* Default exit sequence for state UART_config */
	stateConfVector[0] = Statechart::State::NO_STATE;
}

/* Default exit sequence for region main region */
void Statechart::exseq_main_region()
{
	/* Default exit sequence for region main region */
	/* Handle exit of all possible states (of Statechart.main_region) at position 0... */
	switch(stateConfVector[ 0 ])
	{
		case Statechart::State::main_region_StateA :
		{
			exseq_main_region_StateA();
			break;
		}
		case Statechart::State::main_region_StateB :
		{
			exseq_main_region_StateB();
			break;
		}
		case Statechart::State::main_region_StateC :
		{
			exseq_main_region_StateC();
			break;
		}
		case Statechart::State::main_region_UART_config :
		{
			exseq_main_region_UART_config();
			break;
		}
		default:
			/* do nothing */
			break;
	}
}

/* Default react sequence for initial entry  */
void Statechart::react_main_region__entry_Default()
{
	/* Default react sequence for initial entry  */
	enseq_main_region_UART_config_default();
}

sc::integer Statechart::react(const sc::integer transitioned_before) {
	/* State machine reactions. */
	return transitioned_before;
}

sc::integer Statechart::main_region_StateA_react(const sc::integer transitioned_before) {
	/* The reactions of state StateA. */
	sc::integer transitioned_after = transitioned_before;
	if (!doCompletion)
	{ 
		if ((transitioned_after) < (0))
		{ 
			if (current.timeEvents.Statechart_main_region_StateA_time_event_0_raised)
			{ 
				exseq_main_region_StateA();
				current.timeEvents.Statechart_main_region_StateA_time_event_0_raised = false;
				enseq_main_region_StateB_default();
				react(0);
				transitioned_after = 0;
			} 
		} 
		if ((transitioned_after) == (transitioned_before))
		{ 
			/* If no transition was taken then execute local reactions */
			transitioned_after = react(transitioned_before);
		} 
	} 
	return transitioned_after;
}

sc::integer Statechart::main_region_StateB_react(const sc::integer transitioned_before) {
	/* The reactions of state StateB. */
	sc::integer transitioned_after = transitioned_before;
	if (doCompletion)
	{ 
		/* Default exit sequence for state StateB */
		stateConfVector[0] = Statechart::State::NO_STATE;
		/* 'default' enter sequence for state StateC */
		enact_main_region_StateC();
		stateConfVector[0] = Statechart::State::main_region_StateC;
		react(0);
	}  else
	{
		/* If no transition was taken then execute local reactions */
		transitioned_after = react(transitioned_before);
	}
	return transitioned_after;
}

sc::integer Statechart::main_region_StateC_react(const sc::integer transitioned_before) {
	/* The reactions of state StateC. */
	sc::integer transitioned_after = transitioned_before;
	if (!doCompletion)
	{ 
		if ((transitioned_after) < (0))
		{ 
			if (current.timeEvents.Statechart_main_region_StateC_time_event_0_raised)
			{ 
				exseq_main_region_StateC();
				current.timeEvents.Statechart_main_region_StateC_time_event_0_raised = false;
				enseq_main_region_StateA_default();
				react(0);
				transitioned_after = 0;
			} 
		} 
		if ((transitioned_after) == (transitioned_before))
		{ 
			/* If no transition was taken then execute local reactions */
			transitioned_after = react(transitioned_before);
		} 
	} 
	return transitioned_after;
}

sc::integer Statechart::main_region_UART_config_react(const sc::integer transitioned_before) {
	/* The reactions of state UART_config. */
	sc::integer transitioned_after = transitioned_before;
	if (doCompletion)
	{ 
		/* Default exit sequence for state UART_config */
		stateConfVector[0] = Statechart::State::NO_STATE;
		/* 'default' enter sequence for state StateA */
		enact_main_region_StateA();
		stateConfVector[0] = Statechart::State::main_region_StateA;
		react(0);
	}  else
	{
		/* If no transition was taken then execute local reactions */
		transitioned_after = react(transitioned_before);
	}
	return transitioned_after;
}

void Statechart::swapInEvents() noexcept {
	current.iface.myEvent_raised = myEvent_raised;
	myEvent_raised = false;
	current.timeEvents.Statechart_main_region_StateA_time_event_0_raised = timeEvents[0];
	timeEvents[0] = false;
	current.timeEvents.Statechart_main_region_StateC_time_event_0_raised = timeEvents[1];
	timeEvents[1] = false;
}

void Statechart::clearInEvents() noexcept {
	myEvent_raised = false;
	timeEvents[0] = false;
	timeEvents[1] = false;
}

void Statechart::microStep() {
	switch(stateConfVector[ 0 ])
	{
		case Statechart::State::main_region_StateA :
		{
			main_region_StateA_react(-1);
			break;
		}
		case Statechart::State::main_region_StateB :
		{
			main_region_StateB_react(-1);
			break;
		}
		case Statechart::State::main_region_StateC :
		{
			main_region_StateC_react(-1);
			break;
		}
		case Statechart::State::main_region_UART_config :
		{
			main_region_UART_config_react(-1);
			break;
		}
		default:
			/* do nothing */
			break;
	}
}

void Statechart::runCycle() {
	/* Performs a 'run to completion' step. */
	if (isExecuting)
	{ 
		return;
	} 
	isExecuting = true;
	swapInEvents();
	doCompletion = false;
	do
	{ 
		if (completed)
		{ 
			doCompletion = true;
		} 
		completed = false;
		microStep();
		doCompletion = false;
	} while (completed);
	isExecuting = false;
}

void Statechart::enter() {
	/* Activates the state machine. */
	if (isExecuting)
	{ 
		return;
	} 
	isExecuting = true;
	/* Default enter sequence for statechart Statechart */
	enseq_main_region_default();
	doCompletion = false;
	do
	{ 
		if (completed)
		{ 
			doCompletion = true;
		} 
		completed = false;
		microStep();
		doCompletion = false;
	} while (completed);
	isExecuting = false;
}

void Statechart::exit() {
	/* Deactivates the state machine. */
	if (isExecuting)
	{ 
		return;
	} 
	isExecuting = true;
	/* Default exit sequence for statechart Statechart */
	exseq_main_region();
	isExecuting = false;
}


